{
  "title": "@chronark/access",
  "description": "A minimal library for access control. It is designed to be used together with opaque access tokens by providing a simple interface to define roles with different access permissions and verifying requests to resources.",
  "date": "2022-11-13T00:00:00.000Z",
  "body": {
    "raw": "A minimal library for access control. It is designed to be used together with opaque access tokens by providing a simple interface to define roles with different access permissions and verifying requests to resources.\r\n\r\n- Fully typed\r\n- Zero dependencies\r\n- Serializable to store in a database\r\n\r\n## Install\r\n\r\n```sh-session\r\nnpm i @chronark/access\r\n```\r\n\r\n## Usage\r\n\r\n```ts\r\nimport { AccessControl, Role } from \"@chronark/access\";\r\n\r\n/**\r\n * Define all your resources and their access patterns\r\n *\r\n * key => resource\r\n * value => array of access types\r\n */\r\ntype Statements = {\r\n  user: [\"read\", \"write\", \"dance\"];\r\n  team: [\"read\", \"write\"];\r\n};\r\n\r\n/**\r\n * Create an access control instance and pass the Statements type to enjoy full\r\n * type safety\r\n */\r\nconst ac = new AccessControl<Statements>();\r\n\r\n/**\r\n * Now you can define one or more roles by specifying the access permissions\r\n *\r\n * This is already fully typed and typescript will let you know if you try to\r\n * use anything, that is not defined in the Statements type.\r\n */\r\nconst role = ac.newRole({\r\n  user: [\"read\", \"write\"],\r\n  team: [\"read\"],\r\n});\r\n\r\n/**\r\n * Simulate storing and retrieving the role in a database\r\n *\r\n * The idea here is, that you can store permissions alongside an API token.\r\n * Now, when you verify the token, you can also verify the access permissions.\r\n */\r\nconst serialized = role.toString();\r\n\r\n/**\r\n * Note how you can pass in the Statements type again, to get full type safety\r\n */\r\nconst recovered = Role.fromString<Statements>(serialized);\r\n\r\n/**\r\n * Validate the role by specifying the resource and the required access\r\n *\r\n * everything is fully typed\r\n */\r\nconst res = recovered.authorize({\"team\", [\"read\"]});\r\n\r\n// res.success => boolean\r\n// res.error => string | undefined provides a reason for failure\r\n```",
    "code": "var Component=(()=>{var h=Object.create;var a=Object.defineProperty;var u=Object.getOwnPropertyDescriptor;var p=Object.getOwnPropertyNames;var y=Object.getPrototypeOf,f=Object.prototype.hasOwnProperty;var m=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),g=(n,e)=>{for(var s in e)a(n,s,{get:e[s],enumerable:!0})},i=(n,e,s,o)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let t of p(e))!f.call(n,t)&&t!==s&&a(n,t,{get:()=>e[t],enumerable:!(o=u(e,t))||o.enumerable});return n};var w=(n,e,s)=>(s=n!=null?h(y(n)):{},i(e||!n||!n.__esModule?a(s,\"default\",{value:n,enumerable:!0}):s,n)),b=n=>i(a({},\"__esModule\",{value:!0}),n);var l=m((_,c)=>{c.exports=_jsx_runtime});var x={};g(x,{default:()=>S,frontmatter:()=>v});var r=w(l()),v={title:\"@chronark/access\",description:\"A minimal library for access control. It is designed to be used together with opaque access tokens by providing a simple interface to define roles with different access permissions and verifying requests to resources.\",repository:\"chronark/access\",date:\"2022-11-13\",published:!0};function d(n){let e=Object.assign({p:\"p\",ul:\"ul\",li:\"li\",h2:\"h2\",pre:\"pre\",code:\"code\"},n.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.p,{children:\"A minimal library for access control. It is designed to be used together with opaque access tokens by providing a simple interface to define roles with different access permissions and verifying requests to resources.\"}),`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsx)(e.li,{children:\"Fully typed\"}),`\n`,(0,r.jsx)(e.li,{children:\"Zero dependencies\"}),`\n`,(0,r.jsx)(e.li,{children:\"Serializable to store in a database\"}),`\n`]}),`\n`,(0,r.jsx)(e.h2,{children:\"Install\"}),`\n`,(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:\"language-sh-session\",children:`npm i @chronark/access\n`})}),`\n`,(0,r.jsx)(e.h2,{children:\"Usage\"}),`\n`,(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:\"language-ts\",children:`import { AccessControl, Role } from \"@chronark/access\";\\r\n\\r\n/**\\r\n * Define all your resources and their access patterns\\r\n *\\r\n * key => resource\\r\n * value => array of access types\\r\n */\\r\ntype Statements = {\\r\n  user: [\"read\", \"write\", \"dance\"];\\r\n  team: [\"read\", \"write\"];\\r\n};\\r\n\\r\n/**\\r\n * Create an access control instance and pass the Statements type to enjoy full\\r\n * type safety\\r\n */\\r\nconst ac = new AccessControl<Statements>();\\r\n\\r\n/**\\r\n * Now you can define one or more roles by specifying the access permissions\\r\n *\\r\n * This is already fully typed and typescript will let you know if you try to\\r\n * use anything, that is not defined in the Statements type.\\r\n */\\r\nconst role = ac.newRole({\\r\n  user: [\"read\", \"write\"],\\r\n  team: [\"read\"],\\r\n});\\r\n\\r\n/**\\r\n * Simulate storing and retrieving the role in a database\\r\n *\\r\n * The idea here is, that you can store permissions alongside an API token.\\r\n * Now, when you verify the token, you can also verify the access permissions.\\r\n */\\r\nconst serialized = role.toString();\\r\n\\r\n/**\\r\n * Note how you can pass in the Statements type again, to get full type safety\\r\n */\\r\nconst recovered = Role.fromString<Statements>(serialized);\\r\n\\r\n/**\\r\n * Validate the role by specifying the resource and the required access\\r\n *\\r\n * everything is fully typed\\r\n */\\r\nconst res = recovered.authorize({\"team\", [\"read\"]});\\r\n\\r\n// res.success => boolean\\r\n// res.error => string | undefined provides a reason for failure\n`})})]})}function k(n={}){let{wrapper:e}=n.components||{};return e?(0,r.jsx)(e,Object.assign({},n,{children:(0,r.jsx)(d,n)})):d(n)}var S=k;return b(x);})();\n;return Component;"
  },
  "_id": "projects/access.mdx",
  "_raw": {
    "sourceFilePath": "projects/access.mdx",
    "sourceFileName": "access.mdx",
    "sourceFileDir": "projects",
    "contentType": "mdx",
    "flattenedPath": "projects/access"
  },
  "type": "Project",
  "slug": "access"
}